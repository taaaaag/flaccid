"""
Playlist matching and export commands for FLACCID (`fla playlist`).
"""

import json
from pathlib import Path
from typing import List, Optional

import typer
from rich.console import Console

from ..core.config import get_settings
import toml
from ..core.playlist import (
    MatchResult,
    PlaylistExporter,
    PlaylistMatcher,
    PlaylistParser,
    PlaylistTrack,
)

console = Console()
app = typer.Typer(
    no_args_is_help=True,
    help="Match local files against a playlist and export the results.",
)


@app.command("match")
def playlist_match(
    input_file: Path = typer.Argument(
        ...,
        exists=True,
        dir_okay=False,
        help="Playlist file to match (e.g., playlist.json, .m3u, .csv).",
    ),
    output: Optional[Path] = typer.Option(
        None, "--output", "-o", help="Output file for the detailed JSON match report."
    ),
    songshift: bool = typer.Option(
        False,
        "--songshift",
        "-s",
        help="Treat input JSON as SongShift format (nested 'tracks' list).",
    ),
):
    """
    Match a playlist against your library and save a detailed report.
    """
    if not output:
        output = input_file.with_suffix(".match.json")

    settings = get_settings()
    # Override with project-local settings.toml if present
    local_file = Path("settings.toml")
    if local_file.exists():
        try:
            local_cfg = toml.loads(local_file.read_text(encoding="utf-8")) or {}
            if "library_path" in local_cfg:
                settings.library_path = (
                    Path(local_cfg["library_path"]).expanduser().resolve()
                )
            if "db_path" in local_cfg:
                settings.db_path = Path(local_cfg["db_path"]).expanduser().resolve()
        except Exception:
            pass
    # Debug: show loaded settings
    console.print(f"üîß Using library_path: [bold]{settings.library_path}[/bold]")
    # Compute effective DB path (fallback if not explicitly set)
    effective_db = settings.db_path or (settings.library_path / "flaccid.db")
    console.print(f"üîß Using db_path: [bold]{effective_db}[/bold]")
    # Respect explicit DB override if configured
    db_path = settings.db_path or (settings.library_path / "flaccid.db")

    console.print(f"üìù Loading tracks from [bold]{input_file.name}[/bold]...")
    parser = PlaylistParser()
    matcher = PlaylistMatcher(db_path)
    exporter = PlaylistExporter()

    try:
        # Parse playlist into PlaylistTrack objects (JSON, M3U, CSV, etc.)
        tracks = parser.parse_file(input_file)

        # Match each track individually and log input/output info
        results = []
        for track in tracks:
            console.print(f"üéµ Input: {track.artist} - {track.title}")
            result = matcher.match_one(track)
            if result.matched_track:
                mt = result.matched_track
                console.print(
                    f"  ‚úÖ Matched: {mt.get('artist', '')} - {mt.get('title', '')} "
                    f"(score: {result.match_score:.1f})"
                )
            else:
                console.print("  ‚ùå No match found")
            results.append(result)
        matched_count = sum(1 for r in results if r.matched_track)

        console.print(
            f"‚úÖ Match complete. Matched {matched_count}/{len(results)} tracks ({matched_count / len(results) * 100:.1f}%)"
        )
        exporter.export(results, output, "json")
        console.print(f"üíæ Full match report saved to: [blue]{output}[/blue]")
        console.print(
            "üëâ You can now use the `export` command on the .match.json file."
        )

    except Exception as e:
        console.print(f"[red]An error occurred: {e}[/red]")
        raise typer.Exit(1)


@app.command("export")
def playlist_export(
    match_file: Path = typer.Argument(
        ...,
        exists=True,
        dir_okay=False,
        help="A .match.json report file generated by the `match` command.",
    ),
    format: str = typer.Option(
        "m3u", "--format", "-f", help="Export format (m3u, json)."
    ),
    output: Optional[Path] = typer.Option(
        None, "--output", "-o", help="Output file path."
    ),
):
    """
    Export a playlist from a match report file.
    """
    if not output:
        output = match_file.with_suffix(f".{format}")

    try:
        with open(match_file, "r", encoding="utf-8") as f:
            data = json.load(f)

        # Support two shapes:
        # 1) Report object with {'results': [...]} produced by flaccid PlaylistExporter
        # 2) Plain list of items (fallback)
        raw_results = data.get("results") if isinstance(data, dict) else data
        if not isinstance(raw_results, list):
            raise ValueError("Invalid match report format")

        results: List[MatchResult] = []
        for item in raw_results:
            try:
                input_payload = item.get("input_track") or item.get("input") or {}
                pt = PlaylistTrack(
                    title=input_payload.get("title", ""),
                    artist=input_payload.get("artist", ""),
                    album=input_payload.get("album", ""),
                    duration=input_payload.get("duration"),
                    isrc=input_payload.get("isrc"),
                )
                matched = item.get("matched_track") or item.get("matched")
                file_path = item.get("file_path")
                results.append(
                    MatchResult(
                        input_track=pt,
                        matched_track=matched,
                        file_path=Path(file_path) if file_path else None,
                    )
                )
            except Exception:
                # Skip malformed entries
                continue

        exporter = PlaylistExporter()
        exporter.export(results, output, format)
        console.print(f"‚úÖ Exported matched tracks to: [blue]{output}[/blue]")

    except Exception as e:
        console.print(f"[red]An error occurred during export: {e}[/red]")
        raise typer.Exit(1)
